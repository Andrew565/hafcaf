{
  "version": 3,
  "sources": ["../src/hafcaf-barista.js", "../src/hafcaf-tamper.js", "../src/hafcaf.js", "../src/index.js"],
  "sourcesContent": ["/**\n * @typedef {import(\"./hafcaf.js\").default} hafcaf\n */\n\n/**\n * @param {{ id: string; [x: string]: any;}} page\n * @param {?string} path\n * @param {hafcaf} hfcf\n */\nconst Barista = (page, path, hfcf) => {\n  /**\n   * @param {{ id: string; [x: string]: any;}} pageObj\n   */\n  const fetchPage = async pageObj => {\n    // lookup either at the path provided or relative to the home page the page whose name matches the pageObj id\n    const pagePath = path || \"pages\";\n    const res = await fetch(`${pagePath}/${pageObj.id}.html`);\n    const innerHTML = res.ok ? await res.text() : \"\";\n    return { ...page, innerHTML }; // return as an object to be processed by addRoute\n  };\n\n  fetchPage(page).then(pageData => hfcf.addRoute(pageData));\n};\n\nexport default Barista;\n\n/**\n * @param {hafcaf} hfcf\n */\nexport function HireBarista(hfcf) {\n  /**\n   * @param {{ id: string; [x: string]: any;}} page\n   * @param {?string} path\n   */\n  hfcf.Barista = (page, path) => Barista(page, path, hfcf);\n}\n", "/**\n * Tamper enables you to utilize a very simple template system.\n * @param {string} tmpl\n * @param {{ [key: string]: any; }} values\n * @example\n * // returns \"<p>My name is Roasty and I like it toasty.</p>\"\n * tamp(\"<p>My name is {name} and I like it {adjective}</p>\", {name: \"Roasty\", adjective: \"toasty\"});\n */\nconst tamp = (tmpl, values) =>\n  Object.keys(values).reduce((acc, key) => {\n    return acc.replace(new RegExp(`{${key}}`, \"g\"), values[key]);\n  }, tmpl);\n\nexport default tamp;\n", "/**\n * hafcaf is initialized as a module using a plain old JavaScript object (POJO).\n * @module hafcaf\n */\nconst hafcaf = {\n  /**\n   * @typedef {Object} route\n   * @prop {string} id  - The identifier to be used for this route.\n   * @prop {string} [linkClass]=null - What classname(s) to add to the 'a' tags used to create menu items.\n   * @prop {string} [linkHTML]=null - What HTML/text to use when creating a menu item for this route. A menu item will not be created if linkHTML is not provided.\n   * @prop {string} [linkTagClass] - What css classes to give to the menu item container for this route.\n   * @prop {string} [pageClass] - What css classes to give to the page for this route.\n   * @prop {string} [innerHTML] - The content of the page. If not provided, will default to config.loadingHTML. Can be set or overwritten later using hafcaf.updateRoute().\n   * @prop {function} [onRender] - A function which will be called each time this route is rendered (made active). Can include multiple functions within itself, if desired. When composing your onRender, keep in mind to take advantage of the hafcaf.listeners collection, which can be used to hold removeEventListener calls and other functions you would like to run when hafcaf switches away from this route.\n   */\n\n  /**\n   * @type {{ [key: string]: route }}\n   * @description A collection of all of the routes registered with hafcaf.\n   */\n  routes: {},\n\n  /**\n   * @typedef {Object} config\n   * @prop {string} activeClass=\"active\" - What classname(s) to apply to the link container for the current route.\n   * @prop {string | undefined} [linkClass] at classname(s) to add to the 'a' tags used to create menu items.\n   * @prop {string} linkTag=\"li\" - What tag to use for the link container for a route's menu item.\n   * @prop {string | undefined} [linkTagClass] - What classname(s) to give to the menu item container for this route.\n   * @prop {string} loadingHTML - The default HTML to display when a route hasn't yet been updated with its real content. Useful when loading routes dynamically using AJAX or Fetch.\n   * @prop {string} mainID=\"main-container\" - The id attribute of the container to which pages should be added.\n   * @prop {string} navID=\"nav-list\" - The id attribute of the container to which menu items should be added.\n   * @prop {string | undefined} [pageClass] - What css classnames to give to route pages.\n   * @prop {string} pageTag=\"div\" - What tag to use when creating a page's container.\n   */\n\n  /** @type {config} */\n  config: {\n    activeClass: \"active\",\n    linkClass: undefined,\n    linkTag: \"li\",\n    linkTagClass: undefined,\n    loadingHTML: \"<p>Loading...</p>\",\n    mainID: \"main-container\",\n    navID: \"nav-list\",\n    pageClass: undefined,\n    pageTag: \"div\"\n  },\n\n  /**\n   * @property {array} exitFunctions - Holds a collection of functions to be called when the current route changes, as a convenience for onRender functions that add event listeners and the like. Especially useful for cancelling subscriptions to streams or long-polling operations. Will get automatically called at the beginning of every routeChange() call.\n   * @type {Function[]}\n   */\n  exitFunctions: [],\n\n  /**\n   * addRoute() is the method to use when you wish to add a route for hafcaf to keep track of. It takes a configuration object, all properties of which are optional except for `id`.\n   * @param {route} newRoute\n   */\n  addRoute(newRoute) {\n    const id = newRoute.id;\n\n    // Check if a route already exists with the given ID\n    if (this.routes[id] !== undefined) {\n      console.error(\n        `A route with the ID ${id} already exists. Please use the updateRoute() method if you wish to update it, or change this route's ID if you still want to add it.`\n      );\n      return;\n    }\n\n    // Add the route to the collection of routes\n    this.routes[id] = newRoute;\n\n    // Add the route to the navigation menu if linkHTML provided\n    if (newRoute.linkHTML) {\n      const newEl = document.createElement(this.config.linkTag);\n\n      const linkTagClass = newRoute.linkTagClass || this.config.linkTagClass;\n\n      if (linkTagClass) {\n        newEl.classList.add(linkTagClass);\n      }\n\n      const newLink = document.createElement(\"a\");\n      newLink.href = `#${id}`;\n      newLink.innerHTML = newRoute.linkHTML;\n\n      // Add classes to the link, if present\n      const linkClass = newRoute.linkClass || this.config.linkClass;\n\n      if (linkClass) {\n        newLink.classList.add(linkClass);\n      }\n\n      newEl.appendChild(newLink);\n      document.getElementById(this.config.navID)?.appendChild(newEl);\n    }\n\n    // Check if the ID already exists in the DOM (i.e. adding an existing page to the dom)\n    const doesNotExist = document.getElementById(id) === null;\n\n    if (doesNotExist) {\n      // Create a new page\n      const newEl = document.createElement(this.config.pageTag);\n      newEl.id = id;\n\n      // Add classes to the page, if present\n      const pageClass = newRoute.pageClass || this.config.pageClass;\n\n      if (pageClass) {\n        newEl.classList.add(pageClass);\n      }\n\n      // If this new route provides html, add it to the DOM, else use the loadingHTML\n      newEl.innerHTML = newRoute.innerHTML || this.config.loadingHTML;\n\n      // Add page to the DOM\n      document.getElementById(this.config.mainID)?.appendChild(newEl);\n    }\n\n    // Get the new hash, which is the route to be rendered\n    const currentRouteID = location.hash.slice(1);\n\n    if (id === currentRouteID) this.routeChange();\n  },\n\n  /**\n   * @property {string} - The id attribute of the route to redirect to if hafcaf is asked to redirect to a route that doesn't exist. When creating your initial html, this should be the last page in the list of pages in your page container.\n   */\n  defaultRouteID: \"home\",\n\n  /**\n   * updateRoute() is used - naturally - to update a route's content. In addition to the page's content, one can also update the route's link's innerHTML and the route's onRender function. updateRoute() calls routeChange() at the end if the user is currently viewing the route that was just updated.\n   * @param {route} routeToUpdate\n   */\n  updateRoute(routeToUpdate) {\n    const id = routeToUpdate.id;\n    const route = this.routes[id];\n\n    if (!route) {\n      console.error(`A route with the ID ${id} does not exist, cannot update it.`);\n      return false;\n    }\n\n    if (routeToUpdate.linkHTML) {\n      // First, find the link's 'a' tag by looking up the link's href\n      const linkEl = document.querySelector(`a[href='#${id}']`);\n\n      // Then, update the link's innerHTML with the new content\n      if (linkEl) linkEl.innerHTML = routeToUpdate.linkHTML;\n    }\n\n    if (routeToUpdate.innerHTML) {\n      // First, find the page via its id\n      const pageEl = document.getElementById(id);\n\n      // Then, update the page's innerHTML with the new content\n      if (pageEl) pageEl.innerHTML = routeToUpdate.innerHTML;\n    }\n\n    if (routeToUpdate.onRender) route.onRender = routeToUpdate.onRender;\n\n    // Get the new hash, which is the route to be rendered\n    const currentRouteID = location.hash.slice(1);\n\n    if (id === currentRouteID) this.routeChange();\n  },\n\n  /**\n   * routeChange() is a function called by hafcaf everytime a route is changed. You likely will not ever need to call it directly. The first thing it does is check to make sure the route desired is being tracked by hafcaf already. If it is, then the next step is to remove the `activeClass` from any existing elements that might have it. Third, if there are any functions in {@link hafcaf.exitFunctions}, then call those. Fourthly, find the menu item for the new active route and make it active. Finally, if the new route has an `onRender` function registered, call it.\n   */\n  routeChange() {\n    // Get the new hash, which is the route to be rendered\n    const routeID = location.hash.slice(1);\n\n    // From the routes known to hafcaf, pick out the matching one\n    // If the desired route is not found, redirect to default page\n    let route = this.routes[routeID] || this.routes[this.defaultRouteID];\n\n    // If the default route doesn't exist yet either, return early\n    if (!route) return;\n\n    // Remove any existing active classes upon route changing\n    const { activeClass } = this.config;\n    for (const el of document.getElementsByClassName(activeClass)) {\n      el.classList.remove(activeClass);\n    }\n\n    // Iterate through the exitFunctions collection and call any functions found there\n    while (this.exitFunctions.length > 0) {\n      // Dispose all of the registered exit functions\n      this.exitFunctions.pop()?.();\n    }\n\n    // Next, find the new route's 'a' tag by looking up the link's href\n    const linkEl = document.querySelector(`a[href='#${route.id}']`);\n\n    // Make it active\n    if (linkEl) linkEl.classList.add(activeClass);\n\n    // If the route has an \"onRender\" callback, call it\n    if (route.onRender !== undefined) route.onRender();\n\n    // Last but not least, make sure the hash location gets updated in case of redirection\n    if (window.location.hash.slice(1) !== route.id) {\n      window.location.hash = route.id;\n    }\n  },\n\n  /**\n   * The init() function assigns its config object as the config (defaults) for hafcaf. Though it's recommended to only change the individual values needed, this option is provided in case you wish to change several or all values at once.\n   *\n   * init() additionally sets up a \"hashchange\" event listener on the window object, so that the routeChange() function will be called when the route changes. Finally, init() will set the hash to the defaultRouteID if it has not already been set (for instance, when following a link to a hafcaf site or refreshing a page) and will then call hafcaf.routeChange() to make sure the pertinent routines are executed.\n   * @param {config} config\n   */\n  init(config) {\n    if (config) this.config = {...this.config, ...config};\n\n    // Add a global listener for 'hashchange', since this framework relies on hash-based routing\n    window.addEventListener(\"hashchange\", () => {\n      this.routeChange();\n    });\n\n    // Set hash to default if no hash\n    if (!window.location.hash) {\n      window.location.hash = this.defaultRouteID;\n    }\n\n    this.routeChange();\n  }\n};\n\nexport default hafcaf;\n", "export { default as Barista, HireBarista } from \"./hafcaf-barista\";\nexport { default as Tamp } from \"./hafcaf-tamper\";\nimport hafcaf from \"./hafcaf\";\nexport default hafcaf;\n"],
  "mappings": "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",
  "names": []
}
